#include "MySerialize.h"
#include "serializeBase.h"
#include "customMsg.h"
#include "Util1.h"
#include "MyLib.h"
#include "globalStuffs.h"
#include "MyConfigs.h"
#include <iostream>
#include "BasicPlayer.h"

#ifdef APP_PLAYER_UI
#include "MyControls.h"
#include "mytree.h"
#include "mainfrm.h"
#include "DialogSearch.h"
#include "resource.h"
#else
#include "resource1.h"
#endif



ADDTOSERIALIZE(CPlayListItem)
ADDTOSERIALIZE(CPlayList)
ADDTOSERIALIZE(MyConfigs)

#ifdef APP_PLAYER_UI
ADDTOSERIALIZE(CMainFrame)
ADDTOSERIALIZE(CMySimpleRebar)
ADDTOSERIALIZE(CMultiSpliltWnd)
ADDTOSERIALIZE(MYTREE)
ADDTOSERIALIZE(dataNode)
ADDTOSERIALIZE(DialogSearch)
#endif


//enum PlayingStatus
FILE& operator<<(FILE& f, const PlayingStatus s)
{
	return f << static_cast<int>(s);
}

FILE& operator>>(FILE& f, PlayingStatus &s)
{
	int *t = (int*)(&s);
	return f >> *t;
}



//FILETIME
FILE& operator<<(FILE& f, const FILETIME &fileTime)
{
	f << fileTime.dwHighDateTime;
	f << fileTime.dwLowDateTime;
	return f;
}

FILE& operator>>(FILE& f, FILETIME &fileTime)
{
	f >> fileTime.dwHighDateTime;
	f >> fileTime.dwLowDateTime;
	return f;
}


#ifdef APP_PLAYER_UI

//MY_REBARBANDINFO
FILE& operator<<(FILE& f, const MY_REBARBANDINFO * mri)
{
	return f << mri->szClassName << mri->bandIndex << mri->bFullWidthAlways << mri->bRemovable << mri->menuID << mri->bShow
		<< mri->info.cbSize << mri->info.fMask << mri->info.fStyle << mri->info.cx << mri->info.cxMinChild;
}

FILE& operator>>(FILE& f, MY_REBARBANDINFO * mri)
{
	return f >> mri->szClassName >> mri->bandIndex >> mri->bFullWidthAlways >> mri->bRemovable >> mri->menuID >> mri->bShow
		>> mri->info.cbSize >> mri->info.fMask >> mri->info.fStyle >> mri->info.cx >> mri->info.cxMinChild;
}

//blockData
FILE& operator<<(FILE& f, const blockData &bd)
{
	UINT len;
	BYTE *data;

	len = bd.GetLength();
	f << len;

	if (len > 0)
	{
		data = new BYTE[len];
		bd.CopyDataOut(data, len);
		fwrite(data, sizeof(BYTE), len, &f);
	}

	return f;
}

FILE& operator>>(FILE& f, blockData * bd)
{
	ATLASSERT(bd->GetLength() == 0);

	UINT len;
	BYTE *data;

	f >> len;

	if (len > 0)
	{
		data = new BYTE[len];
		fread(data, sizeof(BYTE), len, &f);

		bd->Take(blockData(data, len));

		//do no delete . bd taken it.
	}

	return f;
}


//WINDOWPLACEMENT
FILE& operator<<(FILE& f, const WINDOWPLACEMENT& s)
{
	return f << s.length << s.flags << s.showCmd << s.ptMinPosition
		<< s.ptMaxPosition << s.rcNormalPosition;
}

FILE& operator>>(FILE& f, WINDOWPLACEMENT &s)
{
	return f >> s.length >> s.flags >> s.showCmd >> s.ptMinPosition
		>> s.ptMaxPosition >> s.rcNormalPosition;
}



#endif


bool LoadAllPlayList()
{
	if(!ChangeCurDir2PlaylistPath(true))
		return false;

	
	BOOL   bLoaded=TRUE;
	FILE  * f = _tfopen( PLAYLISTINDEXFILE , _T("rb") );
	if (f)
	{
		int totalNum=0;
		*f>>totalNum;

		for (int i=0;i<totalNum;++i)
		{
			int nIndex;
			tstring name;
			TCHAR path[MAX_PATH];
			*f>>nIndex>>name;

			wsprintf(path,_T("%08d.pl"),nIndex);
			
			MyLib::shared()->LoadPlaylist((LPTSTR)path,(TCHAR*)name.c_str());
		}

		fclose(f);
	}

	return bLoaded;
}

bool SaveAllPlayList()
{
	if(!ChangeCurDir2PlaylistPath(true))
		return false;
	
	FILE  * f = _tfopen( PLAYLISTINDEXFILE , _T("wb") );
	if (f)
	{
		int totalNum=MyLib::shared()->GetItemCount();
		*f<<totalNum;

		for (int i=0;i<totalNum;++i)
		{
			int nIndex=i+1;
			auto i2=MyLib::shared()->GetItem(i);
			tstring name=(*i2).GetPlaylistName();

			*f<<nIndex<<name;

			TCHAR path[MAX_PATH];

			wsprintf(path,_T("%08d.pl"),nIndex);

			MyLib::shared()->SavePlaylist(&(*i2),(LPTSTR)path);
		}


		fclose(f);
	}

	return true;
}

bool SaveCoreCfg()
{
	CollectInfo();
	ChangeCurDir2ModulePath();



	FILE  * f = _tfopen( CFGFILENAME , _T("wb") );
	if (f)
	{
		int len;
		/*******************************************/
		//lrc section
		auto lrcDirs=MyLib::shared()->GetLrcDirs();
		len=lrcDirs.size();
		*f<<len;
		
		for (auto k=lrcDirs.begin();k!=lrcDirs.end();++k)
		{	
			*f<<(*k);
		}
		
		
		//Media paths
		MyLib *s = MyLib::shared();
		len=s->GetMediaPaths().size();
		*f<<len;

		auto end = s->GetMediaPaths().end();
		for (auto k = s->GetMediaPaths().begin(); k != end; ++k)
		{
			*f << (*k);
		}

		//***************************************//
		//MyConfigs
		*f<<*GetMyConfigs();
		fclose(f);
	}


	return TRUE;
}



bool LoadCoreCfg()
{
	ChangeCurDir2ModulePath();

	FILE  * f = _tfopen( CFGFILENAME , _T("rb") );
	if (f)
	{
		int size=0;
		MyLib * s=MyLib::shared();
		/*******************************************/
		//lrc dir list
		*f>>size;
		 while (size-->0)
		{
			std::tstring lrcDir;

			*f>>lrcDir;
			if(!lrcDir.empty())
				s->AddFolder2LrcSearchLib(lrcDir.c_str());
		}

		 s->InitLrcLib();
 
		 //Load the Media Lib
		*f>>size;
		 if(size>0)
		{
			 s->InitMonitor(s->GetAutoPlaylist());
			 //s->SetMediaPathCount(size);
			 while (size--)
			 {
				 std::tstring mediaPath;

				* f>>mediaPath;
				 if(!mediaPath.empty())
					 s->AddMediaPath(mediaPath);
			 }
		 }

		 
		 //***************************************//
		 //MyConfigs
		*f>>*GetMyConfigs();

		fclose(f);
	}

	return TRUE;
}




BOOL MyLib::SavePlaylist(LPCPlayList pl,LPTSTR filepath)
{
	BOOL result=TRUE;
	FILE  * f = _tfopen( filepath , _T("wb") );
	if (f)
	{
		*f<<*pl;
		fclose(f);
	}
	return result;
}

LPCPlayList MyLib::LoadPlaylist(LPTSTR filepath,TCHAR* PlName)
{
	LPCPlayList playlist=NULL;
	BOOL result=TRUE;


	FILE  * f = _tfopen( filepath , _T("rb") );
	if (f)
	{
		playlist=new CPlayList();
		if(PlName!=NULL)
		{
			tstring PLName2=PlName;
			playlist->SetPlaylistName(PlName);
		}

		*f>>*playlist;

		m_playLists.push_back(playlist);
		MyLib::shared()->SetSelectedPL(playlist);
		

		if(playlist->IsAuto())
		{
			MyLib::shared()->SetAutoPlaylist(playlist);
			//MyLib::shared()->InitMonitor(playlist);
		}

		fclose(f);
	}


	return playlist;
}


FILE& CPlayList::operator>>(FILE& f) const
{
	f<<m_playlistName<<m_bAuto;

	//m_songList Serialize
	int count=m_songList.size();
	f<<count;

	_songContainer::const_iterator i = m_songList.begin();
	_songContainer::const_iterator end= m_songList.end();
	for (;i!=end;++i)
		f<<*(*i);
	
	return f;
}

FILE& CPlayList::operator<<(FILE& f)
{
	int count=0;
	f>>m_playlistName>>m_bAuto>>count;

	if(count>=0)
	{
		Reserve(count);
		while(count--)
		{
			LPCPlayListItem item(new CPlayListItem);
			f>>*item;
			AddItem(item);
		}
	}

		return f;
}


FILE& CPlayListItem::operator>>(FILE& f) const
{
	return f<<url<<playCount<<starLvl<<title<<artist<<album<<genre<<year;
}

FILE& CPlayListItem::operator<<(FILE& f)
{
	return f>>url>>playCount>>starLvl>>title>>artist>>album>>genre>>year;
}


FILE& MyConfigs::operator>>(FILE& f) const
{
	return f << bResumeOnReboot << playlistIndex << trackIndex << playingStatus << msecPos << playersVolume << playorder << fileTimeUpdateMediaLib << m_iListFontHeight;
}

FILE& MyConfigs::operator<<(FILE& f)
{
	return f >> bResumeOnReboot >> playlistIndex >> trackIndex >> playingStatus >> msecPos >> playersVolume >> playorder >> fileTimeUpdateMediaLib >> m_iListFontHeight;
}



void CollectInfo()
{
	MyConfigs *c=GetMyConfigs();
	MyLib *s=MyLib::shared();
	CBasicPlayer * b=CBasicPlayer::shared();


	c->setPlayersVolume(b->m_curVolume);

	LPCPlayListItem track=s->GetPlayingItem();
	if(track!=NULL && track->isValide() && MyLib::shared()->IsValidePlayList(track->GetPlayList() ))
	{		
		c->playlistIndex=s->Playlist2Index(track->GetPlayList());
		c->trackIndex=track->GetIndex();
	}


	if(c->getResumeOnReboot())
	{
		c->playingStatus=b->m_lastStatus;
		c->msecPos=b->m_msecLastPos;
	}

	c->setPlayersVolume(b->m_curVolume);
	c->playorder=s->GetPlayOrder();


    

	// mediaLibraryPaths;
	
}

void printFileTime(FILETIME &fileTime)
{
	TCHAR lpszString[MAX_PATH];
	SYSTEMTIME stUTC, stLocal;
	FileTimeToSystemTime(&fileTime, &stUTC);
	SystemTimeToTzSpecificLocalTime(NULL, &stUTC, &stLocal);


	// Build a string showing the date and time.
	DWORD dwRet = ::_stprintf(lpszString,
		TEXT("%02d/%02d/%d  %02d:%02d"),
		stLocal.wMonth, stLocal.wDay, stLocal.wYear,
		stLocal.wHour, stLocal.wMinute);

	printf("%s", lpszString);
}

void ValidateCfg()
{
	MyConfigs *c=GetMyConfigs();
	MyLib *s=MyLib::shared();
	CBasicPlayer * b=CBasicPlayer::shared();


	b->SetVolumeByEar(c->getPlayersVolume());
	s->SetPlayOrder(c->playorder);

	LPCPlayList pl= s->Index2Playlist(c->playlistIndex);
	if(pl)
		s->SetItemToPlay(pl->GetItem(c->trackIndex));

	if(c->getResumeOnReboot() )
	{
		if(c->playingStatus==status_playing||c->playingStatus==status_paused)
		{
			b->m_lastStatus=c->playingStatus;
			b->m_msecLastPos=c->msecPos;

			SdMsg(WM_COMMAND,TRUE,MAKEWPARAM(ID_PLAY,0),(LPARAM)0);	
		}
	}




	if (s->GetMediaPaths().size() > 0)
	{
		//get auto playlist
		//clear the playlist
		//add file path to list.
		//rescan the paths

		LPCPlayList  plAuto = s->GetAutoPlaylist();

		//get media path 's last update time.
		//if file changed, rescan it again.
		if (plAuto   && s->GetMediaPaths().size()>0)
		{
			std::tstring strPath = *s->GetMediaPaths().begin();
			LPCTSTR folderPath = (strPath.c_str());

			rescanMediaLibrary(plAuto,folderPath);

			/*
			BOOL isMediaLibChanged = FALSE;

			FILETIME lastWriteTime;
			//folderPath
			//LPCTSTR pp = L"c:\\atxt";
			if (GetFileLastWriteTime(folderPath, lastWriteTime))
			{
				FILETIME lastUpdateTimePlaylist = c->fileTimeForUpdateMediaLib();

				isMediaLibChanged = ::CompareFileTime(&lastWriteTime, &lastUpdateTimePlaylist) > 0;

				printFileTime(lastWriteTime);
				printFileTime(lastUpdateTimePlaylist);

				if (isMediaLibChanged)
				{
					c->setTimeForUpdateMediaLib(lastWriteTime);

					plAuto->DeleteAllItems();

					plAuto->AddFolderByThread(folderPath);
				}
			}
			*/
		}


	}


}

#ifdef APP_PLAYER_UI
int SerializeAllTree(MYTREE *c,FILE& f)
{
	int size=0;
	for (;c;c=c->next)	
	{
		f<<*c;
		if (c->hasChild())
			size+=SerializeAllTree(c->child,f);
	}
	return 0;
}

int ReSerializeAllTree(MYTREE *parent,FILE & f)
{
	int size=0;

	if (parent->childs==NULL)
	{
		return 0;
	}

	MYTREE *c=new MYTREE;
	f>>*c;
	
	c->parent=parent;
	parent->child=c;

	if (c->childs)
		ReSerializeAllTree(c,f);

	MYTREE *last=c;

	for (int i=1;i<parent->childs;++i)
	{
		c=new MYTREE;
		f>>*c;

		last->next=c;
		c->prev=last;
		c->parent=last->parent;

		if (c->childs)
			ReSerializeAllTree(c,f);

		last=c;
	}


	return size;
}

FILE& CMySimpleRebar::operator>>(FILE& f) const
{
	f<<m_bLock;

	for (auto i=m_vecBandInfos.begin();i!=m_vecBandInfos.end();++i)
		f<<*i;
	
	return f;
}

FILE& CMySimpleRebar::operator<<(FILE& f)
{
	bInitFromFile=TRUE;

	f>>m_bLock;

	for (auto i=m_vecBandInfos.begin();i!=m_vecBandInfos.end();++i)
		f>>*i;
	
	return f;
}


FILE& MYTREE::operator>>(FILE& f) const
{
	return f<<childs<<data;
}

FILE& MYTREE::operator<<(FILE& f)
{
	return f>>childs>>data;
}



FILE& dataNode::operator>>(FILE& f) const
{
	f<<nodeName<<rc;
	f<<(type==left_right?1:0);

	f<<wndData;

	int numBars=SplitterBarRects.size();
	f<<numBars;
	if (numBars>0)
		for (auto it=SplitterBarRects.begin();it!=SplitterBarRects.end();++it)
			f<<(*it);
	return f;
}

FILE& dataNode::operator<<(FILE& f)
{
	int leftright;

	f>>nodeName>>rc>>leftright;
	type=leftright?left_right:up_down;

	f>>&wndData;

	int numBars;
	f>>numBars;
	for (int i=0;i<numBars;++i)
	{
		RECT rc;
		f>>rc;
		SplitterBarRects.push_back(rc);
	}

	return f;
}


FILE& CMultiSpliltWnd::operator>>(FILE& f) const
{
	SerializeAllTree(rootTree,f);
	return f;
}

FILE& CMultiSpliltWnd::operator<<(FILE& f)
{
	rootTree=CreateRootTree();
	f>>*rootTree;
	
	ReSerializeAllTree(rootTree,f);

	return f;
}



int SerializeTree(FILE &f,MYTREE *cur)
{
	for (auto i=cur;i;i=i->next)
	{
		f<<(*i);
		if (i->hasChild())
			SerializeTree(f,i);
	}

	return 0;
}

int ReSerializeTree(FILE &f,MYTREE *cur)
{
	f<<(*cur);


	for(int i=0;i<cur->childs;++i)
	{
		MYTREE *newTree=new MYTREE;
		f<<*newTree;

		ReSerializeTree(f,newTree);

		cur->AddChild(newTree);
	}


	return 0;
}




bool SaveUICfg()
{
	ChangeCurDir2ModulePath();

	FILE  * f = _tfopen( UIFILENAME , _T("wb") );
	if (f)
	{
		*f<<(*GetMainFrame());

		fclose(f);
	}
	return TRUE;
}


bool LoadUICfg()
{
	ChangeCurDir2ModulePath();

	FILE  * f = _tfopen( UIFILENAME , _T("rb") );
	if (f)
	{
		*f>>*GetMainFrame();
		fclose(f);
	}
	return FALSE;
}


FILE& CMainFrame::operator>>(FILE& f) const
{
	return	f<<m_uShowState<<m_wndsPlacement<<m_rcConfig<<m_rcLrc<<m_rcProcess<<m_DlgSearch<<m_rcFFT<<m_rcPLMng<<m_rcPLConsole<<m_bShowStatusBar<<m_wndRebar<<m_WndMultiSplitter;
}

FILE& CMainFrame::operator<<(FILE& f)
{
	m_bLoaded=TRUE;
	return	f>>m_uShowState>>m_wndsPlacement>>m_rcConfig>>m_rcLrc>>m_rcProcess>>m_DlgSearch>>m_rcFFT>>m_rcPLMng>>m_rcPLConsole>>m_bShowStatusBar>>m_wndRebar>>m_WndMultiSplitter;
}

FILE& DialogSearch::operator>>(FILE& f) const
{
	return f<<m_bHiden<<m_rc<<m_list.GetSerializeData();
}

FILE& DialogSearch::operator<<(FILE& f)
{
	return f>>m_bHidenLast>>m_rc>>m_list.GetSerializeData();
}
#endif

